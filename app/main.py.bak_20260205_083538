from fastapi import FastAPI, Request, Form, Depends, HTTPException
from fastapi.responses import PlainTextResponse, HTMLResponse, RedirectResponse, FileResponse
from fastapi.templating import Jinja2Templates
from sqlalchemy import select, desc
from sqlalchemy.orm import Session
from dotenv import load_dotenv
import os

def escape_xml(s: str) -> str:
    return (
        (s or "")
        .replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
        .replace("'", "&apos;")
    )
from .db import SessionLocal, init_db
from .models import Customer, Lead, Message, Proposal
from .sally_logic import sally_next_message_and_update_state
from .proposal_engine import generate_proposal_and_pdf

load_dotenv()

app = FastAPI(title="Sally AI")
templates = Jinja2Templates(directory="app/templates")

ADMIN_PASSWORD = os.getenv("ADMIN_PASSWORD", "change-me")

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.on_event("startup")
def on_startup():
    init_db()

def require_admin(password: str | None):
    if not password or password != ADMIN_PASSWORD:
        raise HTTPException(status_code=401, detail="Unauthorized")

@app.get("/", response_class=HTMLResponse)
def home():
    return HTMLResponse("<a href='/admin/leads?pw=...'>Go to Admin</a>")

@app.post("/sms", response_class=PlainTextResponse)
async def sms_webhook(
    request: Request,
    From: str = Form(...),
    Body: str = Form(...),
    db: Session = Depends(get_db),
):
    phone = From.strip()
    body = (Body or "").strip()

    customer = db.scalar(select(Customer).where(Customer.phone == phone))
    if not customer:
        customer = Customer(phone=phone, name=None, email=None)
        db.add(customer)
        db.commit()
        db.refresh(customer)

    lead = db.scalar(
        select(Lead)
        .where(Lead.customer_id == customer.id, Lead.status.in_(["new", "in_progress"]))
        .order_by(desc(Lead.created_at))
    )
    if not lead:
        lead = Lead(
            customer_id=customer.id,
            status="new",
            project_type=None,
            address=None,
            city=None,
            timeline=None,
            occupied=None,
            access_notes=None,
            intake_stage="stage1",
            intake_data={},
        )
        db.add(lead)
        db.commit()
        db.refresh(lead)

    db.add(Message(lead_id=lead.id, direction="in", body=body))
    db.commit()

    reply = sally_next_message_and_update_state(db, lead, body)

    db.add(Message(lead_id=lead.id, direction="out", body=reply))
    db.commit()

    twiml = f"""<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Message>{escape_xml(reply)}</Message>
</Response>"""

    return PlainTextResponse(twiml, media_type="application/xml")


@app.get("/admin/leads", response_class=HTMLResponse)
def admin_leads(request: Request, pw: str | None = None, db: Session = Depends(get_db)):
    require_admin(pw)
    leads = db.scalars(select(Lead).order_by(desc(Lead.created_at))).all()
    return templates.TemplateResponse("leads.html", {"request": request, "leads": leads, "pw": pw})

@app.get("/admin/leads/{lead_id}", response_class=HTMLResponse)
def admin_lead_detail(request: Request, lead_id: int, pw: str | None = None, db: Session = Depends(get_db)):
    require_admin(pw)
    lead = db.get(Lead, lead_id)
    if not lead:
        raise HTTPException(404, "Lead not found")
    msgs = db.scalars(select(Message).where(Message.lead_id == lead_id).order_by(Message.created_at)).all()
    cust = db.get(Customer, lead.customer_id)
    return templates.TemplateResponse(
        "lead_detail.html",
        {"request": request, "lead": lead, "customer": cust, "messages": msgs, "pw": pw},
    )

@app.post("/admin/leads/{lead_id}/proposal")
def admin_generate_proposal(lead_id: int, pw: str = Form(...), db: Session = Depends(get_db)):
    require_admin(pw)
    lead = db.get(Lead, lead_id)
    if not lead:
        raise HTTPException(404, "Lead not found")

    proposal = generate_proposal_and_pdf(db, lead)
    return RedirectResponse(url=f"/admin/proposals/{proposal.id}.pdf?pw={pw}", status_code=303)

@app.get("/admin/proposals/{proposal_id}.pdf")
def admin_download_proposal(proposal_id: int, pw: str | None = None, db: Session = Depends(get_db)):
    require_admin(pw)
    proposal = db.get(Proposal, proposal_id)
    if not proposal or not proposal.pdf_path:
        raise HTTPException(404, "Proposal not found")
    return FileResponse(proposal.pdf_path, media_type="application/pdf", filename=f"proposal-{proposal_id}.pdf")



